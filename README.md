# 언리얼 엔진으로 나만의 볼링 게임 만들기 첫걸음: 개발 일지 🎳

**안녕하세요! 첫 언리얼 엔진 프로젝트로 볼링 게임을 만들어봤습니다.**

아직 미숙한 점이 많지만, 기본적인 볼링 메커니즘을 구현하며 많은 것을 배울 수 있었던 소중한 경험이었습니다. 이번 포트폴리오에서는 개발 과정과 구현된 기능들을 이미지와 함께 기록해보려 합니다.


![볼링 게임 영상](https://velog.velcdn.com/images/kimth1113/post/fd985270-a323-4bef-94bd-aa561f23c8c8/image.gif)


![메인 레벨의 블루프린트](https://velog.velcdn.com/images/kimth1113/post/a5fe9e4b-514e-40b4-b207-eb865f14011e/image.PNG)


### 1. 프로젝트 개요 및 목표

이번 프로젝트는 언리얼 엔진 5를 활용하여 간단한 볼링 게임의 핵심 기능을 구현하는 것을 목표로 했습니다. 주요 목표는 다음과 같습니다:

볼링 레인 환경 구성: 기본적인 볼링 레인과 주변 환경을 만듭니다.

볼 스폰 및 발사: 플레이어가 공을 스폰하고 특정 방향으로 발사할 수 있도록 합니다.

핀 물리 시뮬레이션: 볼링 핀이 공에 맞았을 때 물리적으로 쓰러지도록 구현합니다.

게임 로직: 공의 개수를 관리하고, 게임 오버 조건을 간단하게 구현합니다.

### 2. 게임 환경 구성

먼저 볼링 게임이 진행될 공간을 구성했습니다.
![](https://velog.velcdn.com/images/kimth1113/post/e60d3e7b-8cda-43b6-afb5-ef150a33e8e2/image.PNG)

위 이미지는 제가 직접 만든 볼링 레인의 모습입니다. 기본적인 벽과 바닥을 BSP 브러시를 사용하여 빠르게 배치했습니다. 특히 바닥에는 체커보드 패턴의 머티리얼을 적용하여 시각적인 재미를 더했습니다.

### 3. 볼링 핀 모델링 및 물리 적용

볼링 게임의 핵심 요소인 볼링 핀은 직접 모델링하거나 에셋을 활용할 수 있습니다.

처음에는 BSP 브러시로 원뿔 형태의 핀을 만들어 여기에 물리 시뮬레이션을 적용하려고 시도했습니다. 하지만 한참 동안 삽질을 거듭한 끝에, BSP 브러시에는 직접적인 물리 시뮬레이션 기능이 없다는 것을 알게 되었습니다. 이는 레벨 디자인 초기 프로토타이핑에 주로 사용되는 브러시의 한계였습니다.

결국, BSP 브러시 원뿔 대신 언리얼 엔진에서 기본으로 제공하는 일반 스태틱 메시(Static Mesh) 형태의 원뿔을 레벨로 불러왔습니다. 그리고 볼링 핀의 상단부를 표현하기 위해 그 위에 스피어(Sphere)를 추가하여 원뿔과 스피어를 함께 선택한 후 그룹화했습니다. 이렇게 함으로써 두 오브젝트가 하나의 볼링 핀처럼 취급되도록 했습니다.
![](https://velog.velcdn.com/images/kimth1113/post/408e10b9-3553-4ffc-a135-0251166606d3/image.PNG)

위 이미지는 제가 만든 볼링 공 (BBall)의 스태틱 메시 에디터 모습입니다. 핀도 이와 유사하게 스태틱 메시로 구성된 후, 디테일(Details) 패널에서 Simulate Physics 옵션을 활성화했습니다. 또한, 핀이 자연스럽게 쓰러지도록 중력(Gravity) 값을 적절하게 조절했습니다. 이를 통해 공이 핀에 부딪히면 핀이 물리적으로 자연스럽게 반응하며 쓰러지도록 구현했습니다.

### 4. 볼 스폰 및 발사 로직 (블루프린트)

플레이어가 게임 시작 시 볼을 스폰하고 발사하는 로직은 레벨 블루프린트에서 구현했습니다.
![](https://velog.velcdn.com/images/kimth1113/post/186633d6-7915-4617-a79e-ed4edc11cc71/image.PNG)

Spawn Ball 커스텀 이벤트는 Get Player Pawn과 Get Actor Location, Get Control Rotation 노드를 사용하여 플레이어 캐릭터의 위치와 회전값을 가져옵니다. 이 정보를 기반으로 SpawnActor BBall 노드를 통해 미리 만들어둔 BBall (볼링 공) 액터를 스폰합니다.

여기서 한 가지 시행착오가 있었습니다. SpawnActor BBall의 Return Value (스폰된 볼 액터)를 Launch 노드의 Target 핀에 연결하려고 했으나, 두 핀의 데이터 타입이 맞지 않아 연결되지 않았습니다.

SpawnActor BBall은 새로 생성된 BBall 타입의 액터 레퍼런스를 반환했지만, Launch 노드의 Target은 이 노드가 속한 현재 블루프린트(self)만을 대상으로 요구했습니다.
![](https://velog.velcdn.com/images/kimth1113/post/741307b0-0f45-4439-90c9-690674d4bdb9/image.PNG)

이 문제를 해결하기 위해, 저는 글로벌 함수로 존재했던 Launch 기능을 BBall 블루프린트 안으로 옮겨 BBall의 메소드(Method)로 변환했습니다. 이렇게 Launch 함수를 BBall 클래스 내부에 정의함으로써, Launch 함수의 Target 핀이 BBall 자신(self)을 참조할 수 있게 되어 데이터 타입을 맞출 수 있었습니다.

이제 BBall 블루프린트 내에서 Launch 이벤트가 호출되면, BBall 자신의 Static Mesh Component를 Add Impulse 노드의 Target에 연결하고, Get Actor Forward Vector를 통해 플레이어가 바라보는 방향으로 강한 힘(4000.0)을 주어 볼을 발사하도록 했습니다. 이로써 플레이어가 원하는 방향으로 볼을 던질 수 있게 되었습니다.

### 5. 게임 상태 관리 (블루프린트)

간단한 게임 상태 관리를 위해 볼의 개수를 추적하는 변수와 관련 함수들을 만들었습니다.

Event BeginPlay: 게임 시작 시 호출되어 초기 설정을 합니다.

Space Bar (스페이스바): 플레이어가 스페이스바를 누르면 Has Ball 함수를 호출하여 현재 공이 있는지 확인합니다.

공이 있다면 Spawn Ball을 호출하여 공을 발사하고, Decrease Ball을 통해 공의 개수를 줄입니다.

공이 없다면 "No more Ball. Restart Game!" 메시지를 출력하고, Delay 후 현재 레벨을 다시 로드하여 게임을 재시작합니다.

#### 5.1. Decrease Ball 함수

![](https://velog.velcdn.com/images/kimth1113/post/fcb8bf25-20ef-4bee-b39b-e41935319017/image.PNG)

Decrease Ball 함수는 현재 볼 개수를 1 줄이는 역할을 합니다.

Ball 변수 (아마도 정수형)에서 1을 빼고, 그 값을 다시 Ball 변수에 설정(SET)합니다.

#### 5.2. Has Ball 함수

![](https://velog.velcdn.com/images/kimth1113/post/1053c1f6-b692-4f4e-a49d-087b622e461c/image.PNG)

Has Ball 함수는 현재 볼이 남아있는지 여부를 반환합니다.

Ball 변수의 값이 0보다 큰지 비교하여, 그 결과를 Return Node로 반환합니다. 이 반환 값은 Space Bar 이벤트에서 분기(Branch) 로직에 사용됩니다.

#### 5.3. Print Ball 함수

![](https://velog.velcdn.com/images/kimth1113/post/8ba551c5-1d57-4be5-a647-37ebbfb9c052/image.PNG)

디버깅을 위해 현재 볼의 개수를 화면에 출력하는 Print Ball 함수도 만들었습니다.

Ball 변수의 값을 Print String 노드를 통해 화면에 출력합니다. 이는 개발 과정에서 현재 공의 개수를 빠르게 확인하는 데 유용했습니다.

### 6. 마치며

처음으로 언리얼 엔진으로 게임을 만들어보면서 많은 시행착오를 겪었지만, 블루프린트 시스템의 강력함과 시각적인 직관성에 깊은 인상을 받았습니다. 특히 물리 시뮬레이션을 구현하고, 입력에 따라 액터가 반응하도록 만드는 과정이 매우 흥미로웠습니다.

아직 개선할 점이 많지만, 기본적인 볼링 게임의 골격을 만들 수 있었다는 점에서 큰 성취감을 느낍니다. 앞으로는 UI/UX 개선, 점수 시스템, 카메라 컨트롤 등 더 많은 기능을 추가하여 완성도를 높여나갈 계획입니다.

긴 글 읽어주셔서 감사합니다!
